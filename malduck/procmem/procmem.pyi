import mmap

from typing import (
    Any,
    BinaryIO,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)

from typing_extensions import Literal

from ..extractor import ExtractorModules, ExtractManager

from .region import Region
from ..disasm import Instruction
from ..yara import Yara, YaraMatches

from ..ints import IntType

ProcessMemoryBuffer = Union[bytes, bytearray, mmap.mmap]
T = TypeVar("T", bound="ProcessMemory")

class ProcessMemory:
    f: Optional[BinaryIO]
    memory: Optional[bytearray]
    mapped_memory: Optional[mmap.mmap]
    imgbase: Optional[int]
    regions: List[Region]
    def __init__(
        self,
        buf: ProcessMemoryBuffer,
        base: int = 0,
        regions: Optional[List[Region]] = None,
        **_,
    ) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
    @property
    def m(self) -> bytearray: ...
    def close(self, copy: bool = False) -> None: ...
    @classmethod
    def from_file(cls: Type[T], filename: str, **kwargs) -> T: ...
    @classmethod
    def from_memory(
        cls: Type[T], memory: "ProcessMemory", base: int = None, **kwargs
    ) -> T: ...
    @property
    def length(self) -> int: ...
    def iter_regions(
        self,
        addr: Optional[int] = None,
        offset: Optional[int] = None,
        length: Optional[int] = None,
        contiguous: bool = False,
        trim: bool = False,
    ) -> Iterator[Region]: ...
    def v2p(
        self, addr: Optional[int], length: Optional[int] = None
    ) -> Optional[int]: ...
    def p2v(
        self, off: Optional[int], length: Optional[int] = None
    ) -> Optional[int]: ...
    def is_addr(self, addr: Optional[int]) -> bool: ...
    def addr_region(self, addr: Optional[int]) -> Optional[Region]: ...
    def readp(self, offset: int, length: Optional[int] = None) -> bytes: ...
    def readv_regions(
        self,
        addr: Optional[int] = None,
        length: Optional[int] = None,
        contiguous: bool = True,
    ) -> Iterator[Tuple[int, bytes]]: ...
    def readv(self, addr: int, length: Optional[int] = None) -> bytes: ...
    def readv_until(self, addr: int, s: bytes) -> bytes: ...
    def patchp(self, offset: int, buf: bytes) -> None: ...
    def patchv(self, addr: int, buf: bytes) -> None: ...
    @overload
    def uint8p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint8p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint8p(self, offset: int) -> Optional[int]: ...
    @overload
    def uint16p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint16p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint16p(self, offset: int) -> Optional[int]: ...
    @overload
    def uint32p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint32p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint32p(self, offset: int) -> Optional[int]: ...
    @overload
    def uint64p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint64p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint64p(self, offset: int) -> Optional[int]: ...
    @overload
    def uint8v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint8v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint8v(self, addr: int) -> Optional[int]: ...
    @overload
    def uint16v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint16v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint16v(self, addr: int) -> Optional[int]: ...
    @overload
    def uint32v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint32v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint32v(self, addr: int) -> Optional[int]: ...
    @overload
    def uint64v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def uint64v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def uint64v(self, addr: int) -> Optional[int]: ...
    @overload
    def int8p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int8p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int8p(self, offset: int) -> Optional[int]: ...
    @overload
    def int16p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int16p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int16p(self, offset: int) -> Optional[int]: ...
    @overload
    def int32p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int32p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int32p(self, offset: int) -> Optional[int]: ...
    @overload
    def int64p(self, offset: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int64p(self, offset: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int64p(self, offset: int) -> Optional[int]: ...
    @overload
    def int8v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int8v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int8v(self, addr: int) -> Optional[int]: ...
    @overload
    def int16v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int16v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int16v(self, addr: int) -> Optional[int]: ...
    @overload
    def int32v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int32v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int32v(self, addr: int) -> Optional[int]: ...
    @overload
    def int64v(self, addr: int, fixed: Literal[False]) -> Optional[int]: ...
    @overload
    def int64v(self, addr: int, fixed: Literal[True]) -> Optional[IntType]: ...
    @overload
    def int64v(self, addr: int) -> Optional[int]: ...
    def asciiz(self, addr: int) -> bytes: ...
    def utf16z(self, addr: int) -> bytes: ...
    def _find(
        self,
        buf: bytes,
        query: bytes,
        offset: Optional[int] = None,
        length: Optional[int] = None,
    ) -> Iterator[int]: ...
    def findp(
        self, query: bytes, offset: Optional[int] = None, length: Optional[int] = None
    ) -> Iterator[int]: ...
    def findv(
        self, query: bytes, addr: Optional[int] = None, length: Optional[int] = None
    ) -> Iterator[int]: ...
    def regexp(
        self, query: bytes, offset: Optional[int] = None, length: Optional[int] = None
    ) -> Iterator[int]: ...
    def regexv(
        self, query: bytes, addr: Optional[int] = None, length: Optional[int] = None
    ) -> Iterator[int]: ...
    def disasmv(self, addr: int, size: int, x64: bool = False) -> List[Instruction]: ...
    def extract(
        self, modules: ExtractorModules = None, extract_manager: ExtractManager = None,
    ) -> Optional[List[Dict[str, Any]]]: ...
    def yarap(
        self, ruleset: Yara, offset: Optional[int] = None, length: Optional[int] = None
    ) -> YaraMatches: ...
    def yarav(
        self, ruleset: Yara, addr: Optional[int] = None, length: Optional[int] = None
    ) -> YaraMatches: ...
    def _findbytes(
        self,
        yara_fn: Callable[[Yara, Optional[int], Optional[int]], YaraMatches],
        query: Union[str, bytes],
        addr: Optional[int],
        length: Optional[int],
    ) -> List[int]: ...
    def findbytesp(
        self,
        query: Union[str, bytes],
        offset: Optional[int] = None,
        length: Optional[int] = None,
    ) -> Iterator[int]: ...
    def findbytesv(
        self,
        query: Union[str, bytes],
        addr: Optional[int] = None,
        length: Optional[int] = None,
    ) -> Iterator[int]: ...
    def findmz(self, addr: int) -> Optional[int]: ...
